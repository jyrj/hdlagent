{
    "verilog_problems": [
        {
            "instruction": "Design a module that takes 8 bit signed inputs 'a' and 'b' and has outputs 'div' and 'mod' which are the 6 bit truncated signed results of 'a' by 'b' division and modulus operations, respectively.",
            "response": "module truncated_sign_div_mod (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [5:0] div,\n    output signed [5:0] mod\n);\n  wire signed [7:0] full_div;\n  wire signed [7:0] full_mod;\n  assign full_div = a / b;\n  assign full_mod = a % b;\n  assign div = full_div[5:0];\n  assign mod = full_mod[5:0];\nendmodule\n",
            "name": "truncated_sign_div_mod",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that takes two signed 8 bit inputs 'a' and 'b' and sets the sole output bit 'out_o' when 'a' is less than 'b' by at least 5, ignoring any overflow conditions",
            "response": "module biased_sign_compare (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output out_o\n);\n  assign out_o = (a + 8'sd4) < b;\nendmodule\n",
            "name": "biased_sign_compare",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that takes two 8 bit signed inputs 'a' and 'b' and produces their signed product, added to the value 4, as 16 bit output 'out_o'.",
            "response": "module signed_mult_add (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [15:0] out_o\n);\n  assign out_o = (a * b) + 4'sd4;\nendmodule\n",
            "name": "signed_mult_add",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 1-bit full adder. The inputs are: [0:0]a, [0:0]b, [0:0]cin and the outputs are: [0:0]sum, [0:0]cout.",
            "response": "module full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n  assign sum  = a ^ b ^ cin;\n  assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n",
            "name": "full_adder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs an OR reduction on its 8 bit input bus 'reduce_i'. The output is named 'result_o' and should be one bit as it is the OR of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0]",
            "response": "module or_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = |reduce_i;\nendmodule\n",
            "name": "or_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that implements a variable logical left shift. The shift amount is set by 5 bit input bus 'shift_n_i' and the value being left shifted is a 32 bit input bus 'val_i'. The result is also a 32 bit output bus named 'result_o'. Input(s): shift_n_i[4:0], val_i[31:0]. Output(s): result_o[31:0].",
            "response": "module variable_logical_leftshift (\n    input [4:0] shift_n_i,\n    input [31:0] val_i,\n    output [31:0] result_o\n);\n  assign result_o = val_i << shift_n_i;\nendmodule\n",
            "name": "variable_logical_leftshift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs a NAND reduction on its 8 bit input bus 'reduce_i'. The output is named 'result_o' and should be one bit as it is the NAND of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0].",
            "response": "module nand_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = ~&reduce_i;\nendmodule\n",
            "name": "nand_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs an XOR reduction on its 8 bit input but 'reduce_i'. The output is named 'result_o' and should be one bit as it is the XOR of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0].",
            "response": "module xor_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = ^reduce_i;\nendmodule\n",
            "name": "xor_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a variable logical shift module that takes a 6 bit input named 'shift_n_i' which determines by how many bits the input value must be shifted. A positive 'shift_n_i' value represents the left shift amount, and a negative 'shift_n_i' value represents a right shift amount. This means if 'shift_n_i' is all ones, a right shift by 1 will be performed. If 'shift_n_i' is -32, then a right shift by 32 will be performed, which is the largest right shift possible. The largest left shift possible would thus be 31, as 'shift_n_i' is only 6 bits wide. The value to be shifted is input through a 32 bit bus named 'val_i' and is output from a 32 bit bus named 'result_o'. Input(s): shift_n_i[5:0], val_i[31:0]. Output(s): result_o[31:0].",
            "response": "module variable_logical_shift (\n    input [5:0] shift_n_i,\n    input [31:0] val_i,\n    output [31:0] result_o\n);\n  wire [31:0] left_res_w;\n  wire [31:0] right_res_w;\n  wire [5:0] _2s_c_shift_w;\n\n  assign _2s_c_shift_w = ~(shift_n_i) + 1;\n  assign right_res_w = val_i >> _2s_c_shift_w;\n  assign left_res_w = val_i << shift_n_i[4:0];\n\n  assign result_o = shift_n_i[5] == 1'b1 ? right_res_w : left_res_w;\nendmodule\n",
            "name": "variable_logical_shift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "The _7seg_display module controls a seven-segment display using a 4-bit input `val_i`, representing hexadecimal values (0-F). The module has seven single-bit outputs: `top_left_vert_o`, `top_right_vert_o`, `bot_left_vert_o`, `bot_right_vert_o` for the vertical segments, and `top_horizontal_o`, `mid_horizontal_o`, `bot_horizontal_o` for the horizontal segments. Internally, it uses conditional logic to activate these segments based on the input. For each hexadecimal value, the module sets the segments to display the corresponding character, with conditions ensuring correct representation, including specific handling for lowercase 'b' and 'd' to avoid confusion with similar-looking numbers. The design is purely combinational, with outputs directly and immediately responding to changes in the input value",
            "response": "module _7seg_display (\n    input [3:0] val_i,\n    output top_left_vert_o,\n    output top_right_vert_o,\n    output bot_left_vert_o,\n        output bot_right_vert_o,\n    output top_horizontal_o,\n    output mid_horizontal_o,\n    output bot_horizontal_o\n);\n\n  wire zero, one, two, three, four, five, six, seven, eight, nine;\n  wire A, b, C, d, E, F;\n\n  assign zero = val_i == 4'b0000;\n  assign one = val_i == 4'b0001;\n  assign two = val_i == 4'b0010;\n  assign three = val_i == 4'b0011;\n  assign four = val_i == 4'b0100;\n  assign five = val_i == 4'b0101;\n  assign six = val_i == 4'b0110;\n  assign seven = val_i == 4'b0111;\n  assign eight = val_i == 4'b1000;\n  assign nine = val_i == 4'b1001;\n  assign A = val_i == 4'b1010;\n  assign b = val_i == 4'b1011;\n  assign C = val_i == 4'b1100;\n  assign d = val_i == 4'b1101;\n  assign E = val_i == 4'b1110;\n  assign F = val_i ==  4'b1111;\n\n  assign top_horizontal_o = !one && !four && !b && !d;\n  assign mid_horizontal_o = !zero && !one && !seven && !C;\n  assign bot_horizontal_o = !one && !four && !seven && !nine && !A && !F;\n  assign top_left_vert_o  = !one && !two && !three && !seven && !d;\n  assign bot_left_vert_o  = !one && !three && !four && !seven && !nine;\n  assign top_right_vert_o = !five && !six && !b && !C && !E && !F;\n  assign bot_right_vert_o = !two && !C && !E && !F;\n\nendmodule\n",
            "name": "_7seg_display",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that concatenates and duplicates inputs 8 bit inputs 'a_i' and 'b_i' into a 32 bit bus in the order of a_i, b_i, b_i, a_i. The output wire name is 'result_o'. Input(s): a_i[7:0], b_i[7:0]. Output(s): result_o[31:0].",
            "response": "module ABBA_bus (\n    input [7:0] a_i,\n    input [7:0] b_i,\n    output [31:0] result_o\n);\n  assign result_o = {a_i, b_i, b_i, a_i};\nendmodule\n",
            "name": "ABBA_bus",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs a NOR reduction on its 8 bit input bus 'reduce_i'. The output is named 'result_o' and should be one bit as it is the NOR of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0].",
            "response": "module nor_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = ~|reduce_i;\nendmodule\n",
            "name": "nor_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that sign extends an input int sized wire 'int_i[31:0]' to an output double sized wire 'double_o[63:0]'. Input(s): int_i[31:0]. Output(s): double_o[63:0].",
            "response": "module sign_extend_int_to_double (\n    input [31:0] int_i,\n    output [63:0] double_o\n);\n  wire [31:0] s_ext_w;\n  assign s_ext_w = int_i[31] == 1'b1 ? 32'hFFFFFFFF : 32'd0;\n  assign double_o = {s_ext_w, int_i};\nendmodule\n",
            "name": "sign_extend_int_to_double",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that implements a variable logical right shift. The shift amount is set by 5 bit input bus 'shift_n_i' and the value being right shifted is a 32 bit input bus 'val_i'. The result is also a 32 bit bus output named 'result_o'. Input(s): shift_n_i[4:0], val_i[31:0]. Output(s): result_o[31:0].",
            "response": "module variable_logical_rightshift (\n    input [4:0] shift_n_i,\n    input [31:0] val_i,\n    output [31:0] result_o\n);\n  assign result_o = val_i >> shift_n_i;\nendmodule\n",
            "name": "variable_logical_rightshift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs an AND reduction on its 8 bit input bus 'reduce_i'. The output is named 'result_o' and should be one bit as it is the AND of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0].",
            "response": "module and_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = &reduce_i;\nendmodule\n",
            "name": "and_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that zero extends a 32-bit int input `int_i` to a 64-bit double output `double_o`. Input(s): int_i[31:0]. Output(s): double_o[63:0].",
            "response": "module zero_extend_int_to_double (\n    input [31:0] int_i,\n    output [63:0] double_o\n);\n  assign double_o = {32'd0, int_i};\nendmodule\n",
            "name": "zero_extend_int_to_double",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs a variable arithmetic right shift. It takes input [4:0]'shift_n_i' that represents the shift amount and input [31:0]'val_i' which is the value being shifted. The output is [31:0]'result_o'. Input(s): shift_n_i[4:0], val_i[31:0]. Output(s): result_o[31:0].",
            "response": "module variable_arithmetic_rightshift (\n    input [4:0] shift_n_i,\n    input [31:0] val_i,\n    output [31:0] result_o\n);\n  assign result_o = $signed(val_i) >>> shift_n_i;\nendmodule\n",
            "name": "variable_arithmetic_rightshift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that outputs a 16 bit bus named 'result_o' that is the concatenation of 8 bit bus 'a_i' and 8 bit bus 'b_i', where 'a_i' are the upper 8 bits and 'b_i' are the lower 8 bits. Input(s): a_i[7:0], b_i[7:0]. Output(s): result_o[15:0].",
            "response": "module simple_concatenation (\n    input [7:0] a_i,\n    input [7:0] b_i,\n    output [15:0] result_o\n);\n  assign result_o = {a_i, b_i};\nendmodule\n",
            "name": "simple_concatenation",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that performs an XNOR reduction on its 8 bit input bus 'reduce_i'. The output is named 'result_o' and should be one bit as it is the XNOR of each bit of 'reduce_i'. Input(s): reduce_i[7:0]. Output(s): result_o[0].",
            "response": "module xnor_reduction (\n    input [7:0] reduce_i,\n    output result_o\n);\n  assign result_o = ~^reduce_i;\nendmodule\n",
            "name": "xnor_reduction",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that decodes a 4 bit wide one hot input named 'one_hot_i' into its 2 bit decimal form, which is an output bus named 'decoded_o'. There is an additional output single bit wire named 'err_o' which should go high if 'one_hot_i' is not a valid one hot signal, in which case 'decoded_o' should take on value 0. The input(s) are one_hot_i[3:0]. The output(s) are err_o[0] and decoded_o[1:0]",
            "response": "module one_hot_decoder (\n    input [3:0] one_hot_i,\n    output [1:0] decoded_o,\n    output err_o\n);\n  always_comb begin case (one_hot_i)\n    4'b0001 : begin\n      decoded_o = 2'b00;\n      err_o = 1'b0; end\n    4'b0010 : begin\n      decoded_o = 2'b01;\n      err_o = 1'b0; end\n    4'b0100 : begin\n      decoded_o = 2'b10;\n      err_o = 1'b0; end\n    4'b1000 : begin\n      decoded_o = 2'b11;\n      err_o = 1'b0; end\n    default: begin\n      decoded_o = 2'b00;\n      err_o = 1'b1; end\n  endcase\n  end\nendmodule\n",
            "name": "one_hot_decoder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that takes a 4 bit wide input bus named `element_i` and replicates and concatenates it four times, creating 16 bit wide output bus named `result_o`. Input(s): element_i[3:0]. Output(s): result_o[15:0].",
            "response": "module _4_replication (\n    input [3:0] element_i,\n    output [15:0] result_o\n);\n  assign result_o = {4{element_i}};\nendmodule\n",
            "name": "_4_replication",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a 4:1 multiplexer. The inputs are: [3:0]data_in, [1:0]select and the outputs are: [0:0]data_out.",
            "response": "module mux_4to1 (\n    input [3:0] data_in,\n    input [1:0] select,\n    output reg data_out  // Use reg since we're using procedural assignment\n);\n\n  always_comb begin\n    case (select)\n      2'b00:   data_out = data_in[0];\n      2'b01:   data_out = data_in[1];\n      2'b10:   data_out = data_in[2];\n      2'b11:   data_out = data_in[3];\n      default: data_out = data_in[0];\n    endcase\n  end\n\nendmodule\n\n",
            "name": "mux_4to1",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a 2-to-4 binary decoder. The inputs are: [1:0]in_i and the outputs are: [3:0]out_o.",
            "response": "module decoder_2to4 (\n    input  [1:0] in_i,\n    output [3:0] out_o\n);\n  always @(in_i) begin\n    case (in_i)\n      2'b00:   out_o = 4'b0001;\n      2'b01:   out_o = 4'b0010;\n      2'b10:   out_o = 4'b0100;\n      2'b11:   out_o = 4'b1000;\n      default: out_o = 'b0;\n    endcase\n  end\nendmodule\n",
            "name": "decoder_2to4",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a 4-bit magnitude comparator. The inputs are: [3:0]A, [3:0]B and the outputs are: [0:0]A_gt_B, [0:0]A_eq_B, [0:0]A_lt_B.",
            "response": "module comparator_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    output A_gt_B,  // A > B\n    output A_eq_B,  // A == B\n    output A_lt_B  // A < B\n);\n  assign A_gt_B = (A > B);\n  assign A_eq_B = (A == B);\n  assign A_lt_B = (A < B);\nendmodule\n",
            "name": "comparator_4bit",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design an 8-bit parity generator. The output should be 1 for even parity. The inputs are: [7:0]in_i and the outputs are: [0:0]parity_out.",
            "response": "module even_parity_generator (\n    input [7:0] in_i,\n    output parity_out\n);\n  assign parity_out = ^(in_i[7:0]);\nendmodule\n",
            "name": "even_parity_generator",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a 4-input OR gate using only 2-input OR gates. The inputs are: [0:0]in0, [0:0]in1, [0:0]in2, [0:0]in3 and the output is: [0:0]out_o.",
            "response": "module or_4input (\n    input  in0,\n    input in1,\n    input in2,\n    input in3,\n    output out_o\n);\n  wire or_01, or_23;\n  or (or_01, in0, in1);\n  or (or_23, in2, in3);\n  or (out_o, or_01, or_23);\nendmodule\n",
            "name": "or_4input",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4-to-1 multiplexer. Inputs: [1:0]sel, [3:0]inputs. Output: [0:0]out_o",
            "response": "module alt_mux_4to1 (\n    input [1:0] sel,\n    input [3:0] inputs,\n    output reg out_o\n);\n\n  always @(sel, inputs) begin\n    case (sel)\n      2'b00:   out_o <= inputs[0];\n      2'b01:   out_o <= inputs[1];\n      2'b10:   out_o <= inputs[2];\n      2'b11:   out_o <= inputs[3];\n      default: out_o <= 0;\n    endcase\n  end\n\nendmodule\n",
            "name": "alt_mux_4to1",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a 1-bit full adder. Inputs: [0:0]a, [0:0]b, [0:0]cin. Outputs: [0:0]sum, [0:0]cout",
            "response": "module alt_full_adder (\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n  assign sum  = a ^ b ^ cin;\n  assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n",
            "name": "alt_full_adder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that takes a 4-bit binary input and outputs its 2's complement value. Inputs: [3:0]bin_in. Output: [3:0]twos_out",
            "response": "module twos_complement (\n    input [3:0] bin_in,\n    output reg [3:0] twos_out\n);\n  always @(bin_in) begin\n    twos_out = ~bin_in + 4'b0001;\n  end\nendmodule\n",
            "name": "twos_complement",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with a fixed width of 3. Initialize an output port named 'out_o', whose length is 3 bits. The binary value held at 'out_o' will be all ones.",
            "response": "module parameterized_width (\n    output [2:0] out_o\n);\n     assign out_o = {3{1'b1}};\n endmodule",
            "name": "parameterized_width",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that adds two 8-bit numbers. Inputs: [7:0]a, [7:0]b. Output: [7:0]sum",
            "response": "module adder (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] sum\n);\n  assign sum = a + b;\nendmodule\n",
            "name": "adder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a subtractor module that subtracts 'b' from 'a' for two 8-bit numbers. Inputs: [7:0]a, [7:0]b. Output: [7:0]diff",
            "response": "module subtractor (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] diff\n);\n  assign diff = a - b;\nendmodule\n",
            "name": "subtractor",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that multiplies two 4-bit numbers resulting in an 8-bit output. Inputs: [3:0]a, [3:0]b. Output: [7:0]product",
            "response": "module multiplier (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [7:0] product\n);\n  assign product = a * b;\nendmodule\n",
            "name": "multiplier",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module to divide an 8-bit number 'a' by a 4-bit number 'b' and provide quotient and remainder outputs. Inputs: [7:0]a, [3:0]b. Outputs: [7:0]quotient, [3:0]remainder",
            "response": "module divider (\n    input  [7:0] a,\n    input  [3:0] b,\n    output [7:0] quotient,\n    output [3:0] remainder\n);\n  assign quotient  = a / b;\n  assign remainder = a % b;\nendmodule\n",
            "name": "divider",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that computes the modulus of two 4-bit numbers 'a' and 'b'. Inputs: [3:0]a, [3:0]b. Output: [3:0]result",
            "response": "module modulus_calculator (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n  assign result = a % b;\nendmodule\n",
            "name": "modulus_calculator",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with input: [7:0]a and output: [7:0]result that shifts an 8-bit number to the left by 2 positions.",
            "response": "module left_shifter (\n    input  [7:0] a,\n    output [7:0] result\n);\n  assign result = a << 2;\nendmodule\n",
            "name": "left_shifter",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with inputs: [3:0]a, [3:0]b and output: [0:0]equal that checks if two 4-bit numbers are equal.",
            "response": "module equality_check (\n    input [3:0] a,\n    input [3:0] b,\n    output equal\n);\n  assign equal = (a == b);\nendmodule\n",
            "name": "equality_check",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module with inputs: [7:0]a, [7:0]b and output: [0:0]greater that compares two 8-bit numbers and outputs if 'a' is greater than 'b'.",
            "response": "module greater_than_check (\n    input [7:0] a,\n    input [7:0] b,\n    output greater\n);\n  assign greater = (a > b);\nendmodule\n",
            "name": "greater_than_check",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with inputs: [7:0]a, [7:0]b and output: [0:0]less_eq that checks if an 8-bit number is less than or equal to another 8-bit number.",
            "response": "module less_equal_check (\n    input [7:0] a,\n    input [7:0] b,\n    output less_eq\n);\n  assign less_eq = (a <= b);\nendmodule\n",
            "name": "less_equal_check",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module with inputs: [3:0]a, [3:0]b and output: [0:0]result that computes the logical AND between two 4-bit numbers.",
            "response": "module logical_and (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [0:0] result\n);\n  assign result = a && b;\nendmodule\n",
            "name": "logical_and",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with inputs: [3:0]a, [3:0]b and output: [0:0]result that computes the logical OR between two 4-bit numbers.",
            "response": "module logical_or (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [0:0] result\n);\n  assign result = a || b;\nendmodule\n",
            "name": "logical_or",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with input: [3:0]a and output: [0:0]result that negates a 4-bit input `a`.",
            "response": "module logical_not (\n    input  [3:0] a,\n    output [0:0] result\n);\n  assign result = !a;\nendmodule\n",
            "name": "logical_not",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with input: [3:0]a and output: [0:0]result that outputs '1' if the 4-bit input `a` is even, and '0' otherwise.",
            "response": "module check_even (\n    input [3:0] a,\n    output reg result\n);\n  always @(a) begin\n    if (a[0] == 0) result = 1;\n    else result = 0;\n  end\nendmodule\n",
            "name": "check_even",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module with inputs: [1:0]sel, [7:0]i0, [7:0]i1, [7:0]i2 and output: [7:0]out_o that takes a 2-bit selector and multiplexes between three 8-bit inputs. The default output should be 0.",
            "response": "module mux (\n    input [1:0] sel,\n    input [7:0] i0,\n    input [7:0] i1,\n    input [7:0] i2,\n    output reg [7:0] out_o\n);\n  always @(sel, i0, i1, i2) begin\n    case (sel)\n      2'b00:   out_o = i0;\n      2'b01:   out_o = i1;\n      2'b10:   out_o = i2;\n      default: out_o = 8'b00000000;\n    endcase\n  end\nendmodule\n",
            "name": "mux",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module with input: [7:0]a and output: [0:0]o that sets the output to '1' if the 8-bit input is in the range [32, 64].",
            "response": "module check_range (\n    input [7:0] a,\n    output reg o\n);\n  always @(a) begin\n    if (a >= 32 && a <= 64) o = 1;\n    else o = 0;\n  end\nendmodule\n",
            "name": "check_range",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module with input: [3:0]a and output: [1:0]count that counts the number of '1's in a 4-bit input and outputs a 2-bit result.",
            "response": "module count_ones (\n    input [3:0] a,\n    output reg [1:0] count\n);\n  always @(a) begin\n    count = a[0] + a[1] + a[2] + a[3];\n  end\nendmodule\n",
            "name": "count_ones",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that encodes a 2-bit input '[1:0]a' into a 4-bit one-hot encoded output '[3:0]one_hot'.",
            "response": "module one_hot_encoder (\n    input [1:0] a,\n    output reg [3:0] one_hot\n);\n  always @(a) begin\n    case (a)\n      2'b00:   one_hot = 4'b0001;\n      2'b01:   one_hot = 4'b0010;\n      2'b10:   one_hot = 4'b0100;\n      2'b11:   one_hot = 4'b1000;\n      default: one_hot = 4'b0000;\n    endcase\n  end\nendmodule",
            "name": "one_hot_encoder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that demonstrates the use of a local variable. The input: [7:0]a and the outputs: [15:0]o, [0:0]is_even, It should take an 8-bit input 'a' and set a 1-bit output 'is_even' to '1' if 'a' is even. Output 'o' should hold the same value as 'is_even'",
            "response": "module local_variable_demo (\n    input  [ 7:0] a,\n    output [15:0] o,\n    output [ 0:0] is_even\n);\n  reg is_even;  // This is a local variable\n  always @(a) begin\n    is_even = a[0] == 0;\n  end\n  assign o = is_even;\nendmodule\n",
            "name": "local_variable_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module with two always blocks that share a common variable 'shared_var'. The input: [7:0]a and the outputs: [7:0]o, [7:0]shared_var. The fireset block should update 'shared_var' with input 'a', and the second block should set output 'o' to 'shared_var'.",
            "response": "module shared_variable_demo (\n    input  [7:0] a,\n    output [7:0] o,\n    output [7:0] shared_var\n);\n  reg [7:0] shared_var;  // This variable is shared between the two blocks\n  always @(a) begin\n    shared_var = a;\n  end\n  always @(shared_var) begin\n    o = shared_var;\n  end\nendmodule\n",
            "name": "shared_variable_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that utilizes both a parameter and a localparam to set a 4-bit output 'o' to a specific value. The parameter should be the value 9, and the localparam should be value of the parameter plus one. 'o' will take the value of the localparam.",
            "response": "module param_demo (\n    output reg [3:0] o\n);\n\n  parameter reg [3:0] FixedVal = 4'b1001;\n  localparam reg [3:0] ModifiedVal = FixedVal + 1;\n\n  initial begin\n    o = ModifiedVal;\n  end\n\nendmodule\n",
            "name": "param_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that showcases a wire 'w' being driven by two continuous assignments. The inputs: [0:0]a, [0:0]b, [0:0]sel and the outputs: [0:0]w, [0:0]w1, [0:0]w2. 'w1' is the bitwise AND of 'a' and 'b', while 'w2' is the bitwise OR of 'a' and 'b'. 'w' will be set to the value of 'w1' when 'sel' is high, and the value of 'w2' when 'sel' is low.",
            "response": "module wire_drive_demo (\n    input  a,\n    input b,\n    input sel,\n    output w,\n    output w1,\n    output w2\n);\n  wire w1, w2;\n  assign w1 = a & b;\n  assign w2 = a | b;\n  assign w  = sel ? w1 : w2;\nendmodule\n",
            "name": "wire_drive_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that uses a localparam to set an 8-bit output 'o' to a constant value of 8'b10101010..",
            "response": "module constant_demo (\n    output reg [7:0] o\n);\n  localparam reg [7:0] ConstanVal = 8'b10101010;\n  initial begin\n    o = ConstanVal;\n  end\nendmodule\n",
            "name": "constant_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that demonstrates the difference between a `parameter` and a `localparam`. The parameters value should be 10 and the local parameters value should be one greater than that. Set 'o' to the value of the local parameter. The module has one output 4-bit `o`",
            "response": "module param_difference_demo (\n    output [3:0] o\n);\n\n  parameter reg [3:0] PARAM_VAL = 4'b1010;\n  localparam reg [3:0] LocalparamVal = PARAM_VAL + 1;  // Renamed to CamelCase\n\n\n  assign o = LocalparamVal;\n\nendmodule\n",
            "name": "param_difference_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module which takes a 4-bit input 'a' and outputs 'o' as 1 if 'a' is equal to a binary literal of value 11.",
            "response": "module binary_literal_demo (\n    input [3:0] a,\n    output o\n);\n  assign o = (a == 4'b1011) ? 1'b1 : 1'b0;\nendmodule\n",
            "name": "binary_literal_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that showcases the use of both base and width specifiers for a constant. Use the value to set an 8-bit output 'o' to be 170 in decimal.",
            "response": "module base_width_demo (\n    output reg [7:0] o\n);\n\n  localparam reg [7:0] ConstantVal = 8'd170;  // 8-bit decimal constant 170 is binary 10101010\n\n  initial begin\n    o = ConstantVal;\n  end\n\nendmodule\n",
            "name": "base_width_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that uses a hexadecimal literal to set a 16-bit output 'o' set to value 0xA55A.",
            "response": "module hex_literal_demo (\n    output reg [15:0] o\n);\n  localparam reg [15:0] HexVal = 16'hA55A;  // 16-bit hexadecimal constant\n  initial begin\n    o = HexVal;\n  end\nendmodule\n",
            "name": "hex_literal_demo",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that computes the bitwise AND operation. Inputs: [7:0]a, [7:0]b. Outputs: [7:0]o.",
            "response": "module bitwise_and (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] o\n);\n  assign o = a & b;\nendmodule\n",
            "name": "bitwise_and",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that calculates the bitwise OR operation. Inputs: [7:0]a, [7:0]b. Outputs: [7:0]o.",
            "response": "module bitwise_or (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] o\n);\n  assign o = a | b;\nendmodule\n",
            "name": "bitwise_or",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module which computes the bitwise XOR operation. Inputs: [7:0]a, [7:0]b. Outputs: [7:0]o.",
            "response": "module bitwise_xor (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] o\n);\n  assign o = a ^ b;\nendmodule\n",
            "name": "bitwise_xor",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Develop a module that inverts the bits. Inputs: [7:0]a. Outputs: [7:0]o.",
            "response": "module bitwise_not (\n    input  [7:0] a,\n    output [7:0] o\n);\n  assign o = ~a;\nendmodule\n",
            "name": "bitwise_not",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that shifts bits left by two positions. Inputs: [7:0]a. Outputs: [7:0]o.",
            "response": "module left_shift (\n    input  [7:0] a,\n    output [7:0] o\n);\n  assign o = a << 2;\nendmodule\n",
            "name": "left_shift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that shifts bits right by three positions. Inputs: [7:0]a. Outputs: [7:0]o.",
            "response": "module right_shift (\n    input  [7:0] a,\n    output [7:0] o\n);\n  assign o = a >> 3;\nendmodule\n",
            "name": "right_shift",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that combines multiple bitwise operations. Inputs: [7:0]a, [7:0]b. Outputs: [7:0]o. The module should take two 8-bit inputs 'a' and 'b', and produce an 8-bit output 'o' that is the result of '(a AND b) XOR (a OR b)'.",
            "response": "module combined_operations (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] o\n);\n  assign o = (a & b) ^ (a | b);\nendmodule\n",
            "name": "combined_operations",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that utilizes a for loop to find the sum of each bit of input 'data'. Inputs: [7:0]data. Outputs: [3:0]sum.",
            "response": "module vector_sum (\n    input [7:0] data,\n    output reg [3:0] sum\n);\n  integer i;\n  always @(data) begin\n    sum = 0;\n    for (i = 0; i < 8; i = i + 1) sum = sum + data[i];\n  end\nendmodule\n",
            "name": "vector_sum",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that computes both the sum and difference of two 4-bit inputs 'a' and 'b' concurrently, producing two 4-bit outputs 'sum' and 'diff'. The inputs: [3:0]a, [3:0]b and the outputs: [3:0]sum, [3:0]diff.",
            "response": "module concurrent_arithmetic (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] sum,\n    output [3:0] diff\n);\n  assign sum  = a + b;\n  assign diff = a - b;\nendmodule\n",
            "name": "concurrent_arithmetic",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that has two input signals 'a' and 'b'. Produce an output 'o1' that represents the AND operation and an output 'o2' that represents the OR operation. Both operations should be calculated concurrently. The inputs: a, b and the outputs: [0:0]o1, o2.",
            "response": "module concurrent_logic (\n    input  a,\n    input b,\n    output o1,\n    output o2\n);\n  assign o1 = a & b;\n  assign o2 = a | b;\nendmodule\n",
            "name": "concurrent_logic",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module for multiplication and addition of two inputs. The inputs: [3:0]m1, m2 and the outputs: [7:0]product, [4:0]sum.",
            "response": "module concurrent_math (\n    input [3:0] m1,\n    input [3:0] m2,\n    output reg [7:0] product,\n    output [4:0] sum\n);\n  always @(m1, m2) product = m1 * m2;\n  always @(m1, m2) sum = m1 + m2;\nendmodule\n",
            "name": "concurrent_math",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that concurrently calculates the bitwise AND, OR, and XOR of two 4-bit vectors 'v1' and 'v2'. The results should be stored in outputs 'and_result', 'or_result', and 'xor_result' respectively. The inputs: [3:0]v1, [3:0]v2 and the outputs: [3:0]and_result, [3:0]or_result, [3:0]xor_result.",
            "response": "module bitwise_operations (\n    input  [3:0] v1,\n    input  [3:0] v2,\n    output [3:0] and_result,\n    output [3:0] or_result,\n    output [3:0] xor_result\n);\n  assign and_result = v1 & v2;\n  assign or_result  = v1 | v2;\n  assign xor_result = v1 ^ v2;\nendmodule\n",
            "name": "bitwise_operations",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a module that takes a single-bit input 'in1' and produces a single-bit output 'out1', which is the inverted version of 'in1'. The goal is to invert a single-bit input. The input: in1 and the output: [0:0]out1.",
            "response": "module inverter (\n    input in1,\n    output [0:0] out1\n);\n  assign out1 = ~in1;\nendmodule\n",
            "name": "inverter",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that accepts a 4-bit binary number as input and outputs the corresponding 2's complement of that number. The goal is to calculate the 2's complement of a binary number. The input: bin_input and the output: [3:0]complement_output.",
            "response": "module assign_twos_complement (\n    input  [3:0] bin_input,\n    output [3:0] complement_output\n);\n  assign complement_output = ~bin_input + 4'b0001;\nendmodule\n",
            "name": "assign_twos_complement",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a module that produces a 4-bit Gray code output 'gray_out' from a 4-bit binary input 'bin_in'. The input: bin_in and the output: [3:0]gray_out",
            "response": "module bin_to_gray (\n    input  [3:0] bin_in,\n    output [3:0] gray_out\n);\n  assign gray_out = bin_in ^ (bin_in >> 1);\nendmodule\n",
            "name": "bin_to_gray",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a module that accepts two 4-bit inputs. The module should have two outputs 'O1' and 'O2'. 'O1' should hold the result of A AND B, while 'O2' should hold the result of A OR B. The input: [3:0]A, B and the output: [3:0]O1, [3:0]O2.",
            "response": "module basic_logic (\n    input  [3:0] A,\n    input  [3:0] B,\n    output [3:0] O1,\n    output [3:0] O2\n);\n  assign O1 = A & B;\n  assign O2 = A | B;\nendmodule\n",
            "name": "basic_logic",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Implement a 4-bit parity generator. parity_generator which calculates the parity of a 4-bit input. The input, named data_in, is 4 bits wide. The output, named parity_out, is a single bit representing the even parity of the input. The even parity is generated such that the total number of '1' bits in the combined input and output is even, where the output is high if the number of 1's in the input is even, and low if the number of 1's in the input is odd.",
            "response": "module parity_generator (\n    input [3:0] data_in,\n    output reg parity_out\n);\n  always @(data_in) begin\n    parity_out <= ^data_in;\n  end\nendmodule\n\n\n",
            "name": "parity_generator",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "The module, sign_extender, performs sign extension on its input. It takes an 8-bit number original and extends it to a 16-bit signed number sign_extended_original. If the MSB of the original is 1, the sign_extended bits are all set to 1; if it's 0, they are set to 0. Inputs: `original` (Size: 8 bits): The original number to be sign-extended. Outputs: `sign_extended_original` (Size: 16 bits): The sign-extended result.",
            "response": "module sign_extender (\n    input [7:0] original,\n    output reg [15:0] sign_extended_original);\n  wire [7:0] sign_extend;\n  generate genvar i;\n  for (i = 0; i < 8; i = i + 1) begin : gen_sign_extend\n    assign sign_extend[i] = (original[7]) ? 1'b1 : 1'b0;\n  end\n  endgenerate\n  always_comb begin\n  sign_extended_original = {sign_extend, original};\n  end\nendmodule",
            "name": "sign_extender",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create an 8-bit adder using 4-bit adder module, module adder_4bit has 2 4-bit input `a`, `b` and one-bit `cin` as input and 4-bit `sum` and 1-bit `cout` as output. You must also provide the implementation of the 4-bit adder as a submodule to the 8-bit adder. The adder_8bit module has 8-bit input `a` and `b`, 1-bit `cin` and 8-bit `sum` and 1-bit `cout` as output",
            "response": "module adder_8bit (\n    input  [7:0] a,\n    b,  // 8-bit inputs\n    input        cin,  // Carry input for least significant 4 bits\n    output [7:0] sum,  // 8-bit sum output\n    output       cout  // Carry output for most significant bit\n);\n\n  wire c4;  // Carry from the 4th bit\n\n  adder_4bit adderLSB (  // Adder for least significant 4 bits\n      .a(a[3:0]),\n      .b(b[3:0]),\n      .cin(cin),\n      .sum(sum[3:0]),\n      .cout(c4)\n  );\n\n  adder_4bit adderMSB (  // Adder for most significant 4 bits\n      .a(a[7:4]),\n      .b(b[7:4]),\n      .cin(c4),\n      .sum(sum[7:4]),\n      .cout(cout)\n  );\n\nendmodule\n\nmodule adder_4bit (\n    input  [3:0] a,\n    input  [3:0] b,  // 4-bit inputs\n    input        cin,  // Carry input\n    output [3:0] sum,  // 4-bit sum output\n    output       cout  // Carry output\n);\n\n  wire [3:0] c;  // Internal carry wires\n\n  assign {cout, sum} = a + b + cin;  // Simple 4-bit addition\n\nendmodule\n\n",
            "name": "adder_8bit",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4-bit binary to gray code converter using combinational logic circuits, the input is a 4-bit binary_code and the output is a 4-bit gray_code.\n\nbinary Code: B3 B2 B1 B0\nGray Code: G3 G2 G1 G0\n\nWhere B3 = B3 xor B2, G2 = B2 xor B1, G1 = B1 xor B0, G0 = B0. Input(s): [3:0]binary_code. Output(s): [3:0]gray_code.",
            "response": "module Binary_to_Gray (\n    input [3:0] binary_code,  // Declare 4-bit binary code as input\n    output [3:0] gray_code  // Declare 4-bit Gray code as output\n);\n\n  // xor operation between the binary bits to obtain gray code\n  assign gray_code[3] = binary_code[3];\n  assign gray_code[2] = binary_code[3] ^ binary_code[2];\n  assign gray_code[1] = binary_code[2] ^ binary_code[1];\n  assign gray_code[0] = binary_code[1] ^ binary_code[0];\n\nendmodule\n\n",
            "name": "Binary_to_Gray",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Create a 2-bit comparator  which will accept two 2-bit numbers as input and generate the outputs less than, equal to, and greater than. The inputs are 2-bit `A` and `B`, the outputs are 1-bit `LT`, `EQ` and `GT`",
            "response": "module comparator_2bit (\ninput  [1:0] A,\ninput  [1:0]  B,\noutput    LT,\noutput    EQ,\noutput    GT\n);\n\n  assign LT = A < B;\n  assign EQ = A == B;\n  assign GT = A > B;\nendmodule\n\n",
            "name": "comparator_2bit",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4 bit comparator which takes unsigned inputs A[3:0] and B[3:0] and has output Y[1:0]. If A is greater than B then Y should be 1, if A is less than B then Y should be 3, and if they are equal then Y should be 0.",
            "response": "module comparator_4bit_1 (\n    input [3:0] A,  // 4-bit input A\n    input [3:0] B,  // 4-bit input B\n    output signed [1:0] Y  // output showing results\n);\n\n  always_comb begin\n    if (A > B) Y = 2'b01;  // A > B , assign 1 to Y\n    else if (A < B) Y = 2'b11;  // A < B, assign -1 to Y\n    else Y = 2'b00;  // A = B, assign 0 to Y\n  end\n\nendmodule\n",
            "name": "comparator_4bit_1",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a simple 8-bit comparator, the inputs are 2 8-bit `A` and `B` the outputs are `AeqB`, 'AgtB', and 'AltB'. A comparator is a device that compares two binary words and determines their relative magnitudes. The output of a comparator has three states - `AeqB=1` for A==B (equal), `AgtB=1` for A>B (greater), `AltB=1` for A<B (less than). The problem is to design an 8-bit comparator .",
            "response": "module comparator_8bit (\n    input  [7:0] A,\n    input  [7:0] B,\n    output       AeqB,  // When A = B\n    output       AltB,  // When A < B\n    output       AgtB   // When A > B\n);\n\n  assign AeqB = (A == B);\n  assign AltB = (A < B);\n  assign AgtB = (A > B);\n\nendmodule\n\n",
            "name": "comparator_8bit",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design an 8-bit value comparator, the inputs are A[7:0] and B[7:0], and the output is AeqB[1:0] which can assume either value 0, when A < B, value 1 when A == B, or value 2 when A > B.",
            "response": "module comparator_8bit_2 (\n    input  [7:0] A,\n    input  [7:0] B,\n    output [1:0] AeqB\n);\n  assign AeqB = (A > B) ? 2'b10 : (A == B) ? 2'b01 : 2'b00;\nendmodule\n\n",
            "name": "comparator_8bit_2",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4-bit comparator  that will compare two 4-bit numbers, `A` and `B` and set output `equality` a \"1\" if they are equal, a \"0\" if they are not equal, and output from `val_o` which number is larger (in the case of equality, should still output the value). Inputs: A[3:0], B[3:0]. Outputs: equality, val_o[3:0]",
            "response": "module four_bit_equality_comparator (\n    input [3:0] A,\n    input [3:0] B,\n  output [3:0] val_o,\n  output equality\n);\n\n  assign equality = (A == B) ? 1 : 0;\n  assign val_o = A > B ? A : B;\nendmodule\n\n",
            "name": "four_bit_equality_comparator",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a four 4x1 Mux (Module name: four_mux). For the module, you should have 16 inputs (16-bit `In_i`) in a single bus, four select lines 4-bit `s`(S0 to S3), and one single bit output (Out_o) which is determined by the select line. If 's' is zero, then bit zero of 'In_i' should be connected to 'Out_o' and if 's' is the max value 15, then the MSB of 'In_i' should be connected to 'Out_o'. One can extrapolate the rest of the connections from these two examples. The default output value should be the MSB of 'In_i'.",
            "response": "module four_mux (\n    input  [15:0] In_i,  // In_i[1:0] inputs for Mux0, In_i[3:2] inputs for Mux1, and so on\n    input  [ 3:0] S,   // select lines\n    output        Out_o  // output\n);\n\n  always_comb begin\n    case (S)\n      4'b0000: Out_o = In_i[0];\n      4'b0001: Out_o = In_i[1];\n      4'b0010: Out_o = In_i[2];\n      4'b0011: Out_o = In_i[3];\n      4'b0100: Out_o = In_i[4];\n      4'b0101: Out_o = In_i[5];\n      4'b0110: Out_o = In_i[6];\n      4'b0111: Out_o = In_i[7];\n      4'b1000: Out_o = In_i[8];\n      4'b1001: Out_o = In_i[9];\n      4'b1010: Out_o = In_i[10];\n      4'b1011: Out_o = In_i[11];\n      4'b1100: Out_o = In_i[12];\n      4'b1101: Out_o = In_i[13];\n      4'b1110: Out_o = In_i[14];\n      4'b1111: Out_o = In_i[15];\n      default: Out_o = In_i[15];\n    endcase\n  end\nendmodule\n\n",
            "name": "four_mux",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design and implement a 4-bit ripple carry adder using 1-bit FullAdder(inputs: `a`, `b` and `ci`. outputs: `sum` and `co`). A ripple carry adder is a digital circuit that produces the arithmetic sum of two binary numbers. The inputs of `RippleCarryAdder` are 4-bit `a` and `b` and the output is 5-bit `sum`",
            "response": "module RippleCarryAdder (\n    input  [3:0] a,\n    input  [3:0] b,\n    output [4:0] sum\n);\n\n  wire [3:0] co;\n  FullAdder FA0 (\n      .a  (a[0]),\n      .b  (b[0]),\n      .ci (1'b0),\n      .sum(sum[0]),\n      .co (co[0])\n  );\n\n  FullAdder FA1 (\n      .a  (a[1]),\n      .b  (b[1]),\n      .ci (co[0]),\n      .sum(sum[1]),\n      .co (co[1])\n  );\n\n  FullAdder FA2 (\n      .a  (a[2]),\n      .b  (b[2]),\n      .ci (co[1]),\n      .sum(sum[2]),\n      .co (co[2])\n  );\n\n  FullAdder FA3 (\n      .a  (a[3]),\n      .b  (b[3]),\n      .ci (co[2]),\n      .sum(sum[3]),\n      .co (co[3])\n  );\n  assign sum[4] = co[3];\nendmodule\n\nmodule FullAdder (\n    input  a,\n    input  b,\n    input  ci,\n    output sum,\n    output co\n);\n\n  assign {co, sum    } = a + b + ci;\nendmodule",
            "name": "RippleCarryAdder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design an 8-bit ripple carry adder. you have to design a submodule named fulladder where the inputs are `a`, `b` and `cin`, the outputs are `sum` and `cout`. module `ripple_carry_adder_8bit ` uses the fulladder module and has 3 inputs, 2 8-bit inputs `a`, `b` and one-bit `cin`. 8-bit output sun and obe-bit `cout`",
            "response": "module ripple_carry_adder_8bit (\n    input [7:0] a,\n   input [7:0] b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n\n  wire [7:0] c;  // Internal carry wires\n\n  // Instantiate 1-bit full adders\n  fulladder fa0 (\n      .a(a[0]),\n      .b(b[0]),\n      .cin(cin),\n      .sum(sum[0]),\n      .cout(c[0])\n  );\n  fulladder fa1 (\n      .a(a[1]),\n      .b(b[1]),\n      .cin(c[0]),\n      .sum(sum[1]),\n      .cout(c[1])\n  );\n  fulladder fa2 (\n      .a(a[2]),\n      .b(b[2]),\n      .cin(c[1]),\n      .sum(sum[2]),\n      .cout(c[2])\n  );\n  fulladder fa3 (\n      .a(a[3]),\n      .b(b[3]),\n      .cin(c[2]),\n      .sum(sum[3]),\n      .cout(c[3])\n  );\n  fulladder fa4 (\n      .a(a[4]),\n      .b(b[4]),\n      .cin(c[3]),\n      .sum(sum[4]),\n      .cout(c[4])\n  );\n  fulladder fa5 (\n      .a(a[5]),\n      .b(b[5]),\n      .cin(c[4]),\n      .sum(sum[5]),\n      .cout(c[5])\n  );\n  fulladder fa6 (\n      .a(a[6]),\n      .b(b[6]),\n      .cin(c[5]),\n      .sum(sum[6]),\n      .cout(c[6])\n  );\n  fulladder fa7 (\n      .a(a[7]),\n      .b(b[7]),\n      .cin(c[6]),\n      .sum(sum[7]),\n      .cout(cout)\n  );\n\nendmodule\n\nmodule fulladder (\n input a,\n  input b,\n input cin, output sum,\n  output cout);\n  assign sum = a ^ b ^ cin;\n\n assign cout = (a & b) | (cin & (a ^ b)); endmodule",
            "name": "ripple_carry_adder_8bit",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4-bit binary to gray-code encoder. Each time the binary inputs change, the corresponding gray code output should be displayed. It has a 4-bit `binary_input` and a 4-bit `gray_code`.",
            "response": "module gray_encoder (\n    input  [3:0] binary_input,\n    output [3:0] gray_code\n);\n\n  // 1st bit is same as binary input\n  assign gray_code[3] = binary_input[3];\n\n  // calculate other bits\n  assign gray_code[2] = binary_input[3] ^ binary_input[2];\n  assign gray_code[1] = binary_input[2] ^ binary_input[1];\n  assign gray_code[0] = binary_input[1] ^ binary_input[0];\n\nendmodule\n\n",
            "name": "gray_encoder",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 2:1 multiplexer it has 3 1-bit inputs `d0` and `d1` and a select `s`, the 1-bit output is `y`  . A multiplexer (mux) is a device that selects one of several analog or digital input signals and forwards the selected input into a single line. Here, a 2:1 mux will select between two inputs, under the control of a select line.",
            "response": "module mux2to1 (\n    input d0,\n    input d1,\n    input s,\n    output reg y\n);\n\n  always_comb begin\n    case (s)\n      0: y = d0;\n      1: y = d1;\n      default: y = 0;\n    endcase\n  end\n\nendmodule\n\n",
            "name": "mux2to1",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design and Implement a 2:1 Multiplexer using Behavioral Modeling the inputs are `a` and `b` and `select`, and the output is `y`.",
            "response": "module mux2x1_behavioral (\n    input a,\n    input b,\n    input select,\n    output reg y\n);\n  always_comb begin\n    case (select)\n      0: y = a;\n      1: y = b;\n      default: y = 0;\n    endcase\n  end\nendmodule\n\n",
            "name": "mux2x1_behavioral",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4:1 Multiplexer(Mux). The inputs are in0, in1, in2, in3 and 2-bit `sel` one-bit output `out_o`.",
            "response": "module mux4to1 (\noutput    out_o,\ninput    in0,\ninput    in1,\ninput    in2,\ninput    in3,\ninput [1:0]    sel\n);\n\n  always_comb begin\n    case (sel)\n      2'b00:   out_o = in0;\n      2'b01:   out_o = in1;\n      2'b10:   out_o = in2;\n      2'b11:   out_o = in3;\n      default: out_o = 0;\n    endcase\n  end\nendmodule\n\n",
            "name": "mux4to1",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a 4:1 Multiplexer, the inputs are a 4-bit `a` and 2-bit `s` and the output is 1-bit `y` .A multiplexer, also known as MUX, is a combinational circuit that selects binary information from one of the many input lines and directs it to a single output line. The selection of a particular input line is controlled by a set of selection lines. \n\nHere, the task is to design a 4:1 MUX which has four input lines, two selection lines, and one output line. The output line depends on the input selected by the selection line.",
            "response": "module mux4to1_b (\n    input [3:0] a,\n    input [1:0] s,\n    output reg y\n);\n\n  always_comb begin\n    case (s)\n      2'b00:   y = a[0];  // When s = 00, fireset input line is selected, So output = a[0]\n      2'b01:   y = a[1];  // When s = 01, second input line is selected, So output = a[1]\n      2'b10:   y = a[2];  // When s = 10, third input line is selected, So output = a[2]\n      2'b11:   y = a[3];  // When s = 11, fourth input line is selected, So output = a[3]\n      default: y = a[0];\n    endcase\n  end\n\nendmodule\n\n",
            "name": "mux4to1_b",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction": "Design a circuit to convert 4-bit binary input into even and odd parity .Problem Requirements: Design the circuit in such a way that it accepts a 4-bit binary as an input (`abcd`). The circuit will generate two outputs, even parity bit (`P1`) and odd parity bit (`P2`).",
            "response": "module parity_2 (\n    input [3:0] abcd,\n    output P1,\n    output P2\n);\n  assign P1 = abcd[3] ^ abcd[2] ^ abcd[1] ^ abcd[0];  //For even parity\n  assign P2 = ~(abcd[3] ^ abcd[2] ^ abcd[1] ^ abcd[0]);  //For odd parity\n\nendmodule\n\n",
            "name": "parity_2",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
	    "instruction": "Defines a floating-point division operation within a digital system, where the `division` module acts as the top-level module. This module orchestrates the division process by coordinating various submodules, each responsible for a specific aspect of floating-point arithmetic. Below is a detailed description of the `division` module and its relationship with the submodules: Top-Level Module: division: Functionality: The division module performs floating-point division of two 32-bit inputs, `a` (dividend) and `b` (divisor), to produce a 32-bit result `res`, which represents the quotient. The module also outputs an `exception` flag to indicate special conditions like division by zero or operations involving NaN (Not a Number) or infinity, as per IEEE 754 standards. Submodules Interaction: The division process begins by normalizing the divisor to enhance the precision of the division operation. This involves adjusting the exponent of the divisor and aligning it for the division process. The module uses iterative refinement techniques, potentially involving submodules like `Multiplication`, `Addition_Subtraction`, and `Iteration`, to converge on an accurate quotient. After completing the iterations, the module adjusts the final quotient based on the original exponent of the dividend to ensure the result is correctly scaled. Submodules: Multiplication: Functionality: Performs floating-point multiplication between two inputs. It handles sign determination, product normalization, rounding, and checks for overflow, underflow, and exceptional conditions. Relation to `division`: Used within the division process for iterative refinement of the quotient and initial normalization of the divisor. Addition_Subtraction: Functionality: Capable of performing either addition or subtraction on two floating-point numbers, based on a control signal. It aligns the operands based on their exponents, performs the operation, and normalizes the result. Relation to `division`: Employed to adjust the intermediate values during the division's iterative refinement steps and for final result adjustment. Iteration: Functionality: Conducts a series of operations involving multiplication and addition/subtraction to refine the quotient iteratively. This module likely encapsulates a specific mathematical approach or algorithm tailored for division. Relation to `division`: Acts as a critical component in the iterative process to converge on the final quotient. The division module may invoke this submodule multiple times, each time with updated operands to progressively refine the quotient. priority_encoder (If used within division) Functionality: Normalizes a significand by shifting it until the MSB is 1, adjusting the exponent accordingly. This is essential for maintaining the floating-point number in a normalized form. Relation to `division`: While not explicitly called within the division module from the provided code snippet, a priority encoder is typically used in floating-point operations to normalize results after arithmetic operations. It might be utilized within Multiplication, Addition_Subtraction, or directly in division to normalize intermediate values or the final result.",
            "response": "// Priority Encoder\n\nmodule priority_encoder(\n input [24:0] significand,\n input [7:0] exp_a,\n output reg [24:0] Significand,\n output [7:0] exp_sub\n);\n\nreg [4:0] shift;\n\nalways @(significand)\nbegin\n casex (significand)\n 25'b1_1xxx_xxxx_xxxx_xxxx_xxxx_xxxx : begin\n Significand = significand;\n shift = 5'd0;\n end\n 25'b1_01xx_xxxx_xxxx_xxxx_xxxx_xxxx : begin\n Significand = significand << 1;\n shift = 5'd1;\n end\n 25'b1_001x_xxxx_xxxx_xxxx_xxxx_xxxx : begin\n Significand = significand << 2;\n shift = 5'd2;\n end\n\n 25'b1_0001_xxxx_xxxx_xxxx_xxxx_xxxx : begin \n Significand = significand << 3;\n shift = 5'd3;\n end\n\n 25'b1_0000_1xxx_xxxx_xxxx_xxxx_xxxx : begin \n Significand = significand << 4;\n shift = 5'd4;\n end\n\n 25'b1_0000_01xx_xxxx_xxxx_xxxx_xxxx : begin\n Significand = significand << 5;\n shift = 5'd5;\n end\n\n 25'b1_0000_001x_xxxx_xxxx_xxxx_xxxx : begin// 24'h020000\n Significand = significand << 6;\n shift = 5'd6;\n end\n\n 25'b1_0000_0001_xxxx_xxxx_xxxx_xxxx : begin// 24'h010000\n Significand = significand << 7;\n shift = 5'd7;\n end\n\n 25'b1_0000_0000_1xxx_xxxx_xxxx_xxxx : begin// 24'h008000\n Significand = significand << 8;\n shift = 5'd8;\n end\n\n 25'b1_0000_0000_01xx_xxxx_xxxx_xxxx : begin// 24'h004000\n Significand = significand << 9;\n shift = 5'd9;\n end\n\n 25'b1_0000_0000_001x_xxxx_xxxx_xxxx : begin// 24'h002000\n Significand = significand << 10;\n shift = 5'd10;\n end\n\n 25'b1_0000_0000_0001_xxxx_xxxx_xxxx : begin// 24'h001000\n Significand = significand << 11;\n shift = 5'd11;\n end\n\n 25'b1_0000_0000_0000_1xxx_xxxx_xxxx : begin // 24'h000800\n Significand = significand << 12;\n shift = 5'd12;\n end\n\n 25'b1_0000_0000_0000_01xx_xxxx_xxxx : begin// 24'h000400\n Significand = significand << 13;\n shift = 5'd13;\n end\n\n 25'b1_0000_0000_0000_001x_xxxx_xxxx : begin // 24'h000200\n Significand = significand << 14;\n shift = 5'd14;\n end\n\n 25'b1_0000_0000_0000_0001_xxxx_xxxx  : begin// 24'h000100\n Significand = significand << 15;\n shift = 5'd15;\n end\n\n 25'b1_0000_0000_0000_0000_1xxx_xxxx : begin // 24'h000080\n Significand = significand << 16;\n shift = 5'd16;\n end\n\n 25'b1_0000_0000_0000_0000_01xx_xxxx : begin// 24'h000040\n Significand = significand << 17;\n shift = 5'd17;\n end\n\n 25'b1_0000_0000_0000_0000_001x_xxxx : begin// 24'h000020\n Significand = significand << 18;\n shift = 5'd18;\n end\n\n 25'b1_0000_0000_0000_0000_0001_xxxx : begin// 24'h000010\n Significand = significand << 19;\n shift = 5'd19;\n end\n\n 25'b1_0000_0000_0000_0000_0000_1xxx : begin// 24'h000008\n Significand = significand << 20;\n shift = 5'd20;\n end\n\n 25'b1_0000_0000_0000_0000_0000_01xx : begin// 24'h000004\n Significand = significand << 21;\n shift = 5'd21;\n end\n\n 25'b1_0000_0000_0000_0000_0000_001x : begin// 24'h000002\n Significand = significand << 22;\n shift = 5'd22;\n end\n\n 25'b1_0000_0000_0000_0000_0000_0001 : begin// 24'h000001\n Significand = significand << 23;\n shift = 5'd23;\n end\n\n 25'b1_0000_0000_0000_0000_0000_0000 : begin// 24'h000000\n Significand = significand << 24;\n shift = 5'd24;\n end\n default : begin\n Significand = (~significand) + 1'b1;\n shift = 8'd0;\n end\n\n endcase\nend\nassign exp_sub = exp_a - shift;\n\nendmodule\n\n//Addition and Subtraction\n\nmodule Addition_Subtraction(\ninput [31:0] a,b,\ninput add_sub_signal,// If 1 then addition otherwise subtraction\noutput exception,\noutput [31:0] res\n);\n\nwire operation_add_sub_signal;\nwire enable;\nwire output_sign;\n\nwire [31:0] op_a,op_b;\nwire [23:0] significand_a,significand_b;\nwire [7:0] exponent_diff;\n\n\nwire [23:0] significand_b_add_sub;\nwire [7:0] exp_b_add_sub;\n\nwire [24:0] significand_add;\nwire [30:0] add_sum;\n\nwire [23:0] significand_sub_complement;\nwire [24:0] significand_sub;\nwire [30:0] sub_diff;\nwire [24:0] subtraction_diff; \nwire [7:0] exp_sub;\n\nassign {enable,op_a,op_b} = (a[30:0] < b[30:0]) ? {1'b1,b,a} : {1'b0,a,b};// For operations always op_a must not be less than b\n\nassign exp_a = op_a[30:23];\nassign exp_b = op_b[30:23];\n\nassign exception = (&op_a[30:23]) | (&op_b[30:23]);// Exception flag sets 1 if either one of the exponent is 255.\n\nassign output_sign = add_sub_signal ? enable ? !op_a[31] : op_a[31] : op_a[31] ;\n\nassign operation_add_sub_signal = add_sub_signal ? op_a[31] ^ op_b[31] : ~(op_a[31] ^ op_b[31]);// Assign significand values according to Hidden Bit.\n\nassign significand_a = (|op_a[30:23]) ? {1'b1,op_a[22:0]} : {1'b0,op_a[22:0]};// If exponent is zero,hidden bit = 0,else 1\nassign significand_b = (|op_b[30:23]) ? {1'b1,op_b[22:0]} : {1'b0,op_b[22:0]};\n\nassign exponent_diff = op_a[30:23] - op_b[30:23];// Exponent difference calculation\n\nassign significand_b_add_sub = significand_b >> exponent_diff;\n\nassign exp_b_add_sub = op_b[30:23] + exponent_diff; \n\nassign perform = (op_a[30:23] == exp_b_add_sub);// Checking if exponents are same\n\n// Add Block //\nassign significand_add = (perform & operation_add_sub_signal) ? (significand_a + significand_b_add_sub) : 25'd0; \n\nassign add_sum[22:0] = significand_add[24] ? significand_add[23:1] : significand_add[22:0];// res will be most 23 bits if carry generated, else least 22 bits.\n\nassign add_sum[30:23] = significand_add[24] ? (1'b1 + op_a[30:23]) : op_a[30:23];// If carry generates in sum value then exponent is added with 1 else feed as it is.\n\n// Sub Block //\nassign significand_sub_complement = (perform & !operation_add_sub_signal) ? ~(significand_b_add_sub) + 24'd1 : 24'd0 ; \n\nassign significand_sub = perform ? (significand_a + significand_sub_complement) : 25'd0;\n\npriority_encoder pe(significand_sub,op_a[30:23],subtraction_diff,exp_sub);\n\nassign sub_diff[30:23] = exp_sub;\n\nassign sub_diff[22:0] = subtraction_diff[22:0];\n\n\n// Output //\nassign res = exception ? 32'b0 : ((!operation_add_sub_signal) ? {output_sign,sub_diff} : {output_sign,add_sum});\n\nendmodule\n\n\n// Multiplication\nmodule Multiplication(\n input [31:0] a,\n input [31:0] b,\n output exception,overflow,underflow,\n output [31:0] res\n);\n\nwire sign,product_round,normalised,zero;\nwire [8:0] exponent,sum_exponent;\nwire [22:0] product_mantissa;\nwire [23:0] op_a,op_b;\nwire [47:0] product,product_normalised; //48 Bits\n\n\nassign sign = a[31] ^ b[31];// XOR of 32nd bit\n\nassign exception = (&a[30:23]) | (&b[30:23]);// Execption sets to 1 when exponent of any a or b is 255\n// If exponent is 0, hidden bit is 0\n\n\n\nassign op_a = (|a[30:23]) ? {1'b1,a[22:0]} : {1'b0,a[22:0]};\n\nassign op_b = (|b[30:23]) ? {1'b1,b[22:0]} : {1'b0,b[22:0]};\n\nassign product = op_a * op_b;// Product\n\nassign product_round = |product_normalised[22:0];// Last 22 bits are ORed for rounding off purpose\n\nassign normalised = product[47] ? 1'b1 : 1'b0;\n\nassign product_normalised = normalised ? product : product << 1;// Normalized value based on 48th bit\n\nassign product_mantissa = product_normalised[46:24] + {21'b0,(product_normalised[23] & product_round)};// Mantissa\n\nassign zero = exception ? 1'b0 : (product_mantissa == 23'd0) ? 1'b1 : 1'b0;\n\nassign sum_exponent = a[30:23] + b[30:23];\n\nassign exponent = sum_exponent - 8'd127 + normalised;\n\nassign overflow = ((exponent[8] & !exponent[7]) & !zero) ;// Overall exponent is greater than 255 then Overflow\n\nassign underflow = ((exponent[8] & exponent[7]) & !zero) ? 1'b1 : 1'b0; // Sum of exponents is less than 255 then Underflow \n\nassign res = exception ? 32'd0 : zero ? {sign,31'd0} : overflow ? {sign,8'hFF,23'd0} : underflow ? {sign,31'd0} : {sign,exponent[7:0],product_mantissa};\n\n\nendmodule\n\n\n// Iteration\nmodule Iteration(\n input [31:0] operand_1,\n input [31:0] operand_2,\n output [31:0] solution\n);\n\nwire [31:0] Intermediate_Value1,Intermediate_Value2;\n\nMultiplication M1(operand_1,operand_2,,,,Intermediate_Value1);\n\n//32'h4000_0000 -> 2.\nAddition_Subtraction A1(32'h4000_0000,{1'b1,Intermediate_Value1[30:0]},1'b0,,Intermediate_Value2);\n\nMultiplication M2(operand_1,Intermediate_Value2,,,,solution);\n\nendmodule\n\n// Division\nmodule division(\n input [31:0] a,\n input [31:0] b,\n output exception,\n output [31:0] res\n);\n\nwire sign;\nwire [7:0] shift;\nwire [7:0] exp_a;\nwire [31:0] divisor;\nwire [31:0] op_a;\nwire [31:0] Intermediate_X0;\nwire [31:0] Iteration_X0;\nwire [31:0] Iteration_X1;\nwire [31:0] Iteration_X2;\nwire [31:0] Iteration_X3;\nwire [31:0] solution;\n\nwire [31:0] denominator;\nwire [31:0] op_a_change;\n\nassign exception = (&a[30:23]) | (&b[30:23]);\n\nassign sign = a[31] ^ b[31];\n\nassign shift = 8'd126 - b[30:23];\n\nassign divisor = {1'b0,8'd126,b[22:0]};\n\nassign denominator = divisor;\n\nassign exp_a = a[30:23] + shift;\n\nassign op_a = {a[31],exp_a,a[22:0]};\n\nassign op_a_change = op_a;\n\n//32'hC00B_4B4B = (-37)/17\nMultiplication x0(32'hC00B_4B4B,divisor,,,,Intermediate_X0);\n\n//32'h4034_B4B5 = 48/17\nAddition_Subtraction X0(Intermediate_X0,32'h4034_B4B5,1'b0,,Iteration_X0);\n\nIteration X1(Iteration_X0,divisor,Iteration_X1);\n\nIteration X2(Iteration_X1,divisor,Iteration_X2);\n\nIteration X3(Iteration_X2,divisor,Iteration_X3);\n\nMultiplication END(Iteration_X3,op_a,,,,solution);\n\nassign res = {sign,solution[30:0]};\nendmodule\n",
	    "name": "division",
	    "pipeline_stages": "0",
            "valid": " "
        },
        {
	    "instruction": "A module named `MBA_module` implements a modified Booth algorithm (MBA) for multiplying two 8-bit numbers `a` and `b`, producing a 16-bit product `p`. The modified Booth algorithm is an efficient multiplication algorithm that reduces the number of required additions by handling two bits of the multiplier `b` at a time. Inputs: `a`: An 8-bit multiplicand. `b`: An 8-bit multiplier. `clock`: A clock signal that triggers the multiplication operation on the negative edge. `Output`: `p`: A 16-bit output that stores the product of `a` and `b`. The module processes the multiplier `b` in 2-bit groups starting from the least significant bit, taking into account the sign extension by including the previous bit in `lookup_tbl`. The multiplication is triggered on the negative edge of the clock, making it synchronous to the clock but initiating on its falling edge.",
            "response": "module MBA_module(p,a,b,clock);\n    output [15:0] p;\n    input [7:0]  a, b;\n    input clock;\n    reg [15:0] p,ans;\n\n    integer i, lookup_tbl;\n    integer operate;\n\n    initial\n    begin\n        p=16'b0;\n        ans=16'b0;\n    end\n\n    always @(negedge clock)\n    begin\n        p=16'b0;\n        for(i=1;i<=7;i=i+2)\n        begin\n            if(i==1)\n                lookup_tbl = 0;\n            else\n                lookup_tbl = b[i-2];\n\n            lookup_tbl = lookup_tbl + 4*b[i] + 2*b[i-1]; \n\n            if(lookup_tbl == 0 || lookup_tbl == 7)\n                operate = 0;\n            else if(lookup_tbl == 3 || lookup_tbl == 4)\n                operate = 2;\n            else\n                operate = 1;\n            if(b[i] == 1)\n                operate = -1*operate;\n\n            case(operate)\n            1:\n                begin\n                    ans=a;\n                    ans=ans<<(i-1);\n                    p=p+ans;\n                end\n            2:\n                begin\n                    ans=a<<1;\n                    ans=ans<<(i-1);\n                    p=p+ans;\n                end\n            -1:\n                begin\n                    ans=~a+1;\n                    ans=ans<<(i-1);\n                    p=p+ans;\n                end\n            -2:\n                begin\n                    ans=a<<1;\n                    ans=~ans+1;\n                    ans=ans<<(i-1);\n                    p=p+ans;\n                end\n            endcase\n        end\n    end\nendmodule\n",
	    "name": "MBA_module",
	    "pipeline_stages": "0",
            "valid": " "
        },
        {
	    "instruction": "Defines a module named `mixColumns`, which is an essential part of the AES (Advanced Encryption Standard) encryption process. The `mixColumns` transformation is one of the four main operations used in each round of AES encryption, designed to operate on the state array and mix the data to ensure diffusion across columns. Inputs and Outputs: Input: `state_in` - A 128-bit input representing the state array. In AES, the state is a 4x4 matrix of bytes, but it's often represented as a 1D array in implementations. Output: `state_out` - A 128-bit output representing the transformed state array after the mixColumns operation. Functionality: The `mixColumns` step treats each column of the state array as a four-term polynomial over the finite field GF(2^8) and multiplies it modulo `x^4 + 1` with a fixed polynomial `c(x) = 03x^3 + 01x^2 + 01x + 02`. Key Components: Multiplication Functions: The module defines two functions, `mb2` and `mb3`, to multiply a byte by 2 and 3, respectively, in the finite field GF(2^8). This multiplication is a key part of the `mixColumns` transformation. `mb2`: Multiplies by 2 using left shift and conditional XOR with `0x1b` (this accounts for the finite field reduction). `mb3`: Multiplies by 3 by adding (XORing in GF(2^8)) the result of `mb2` with the original byte. ",
            "response": "module mixColumns(state_in,state_out);\n\ninput [127:0] state_in;\noutput[127:0] state_out;\n\n\nfunction [7:0] mb2;//multiply by 2\ninput [7:0] x;\n begin \n /* multiplication by 2 is shifting on bit to the left, and if the original 8 bits had a 1 @ MSB,\n xor the result with {1b}*/\n if(x[7] == 1) mb2 = ((x << 1) ^ 8'h1b);\n else mb2 = x << 1; \n end \nendfunction\n\n\n/* \nmultiplication by 3 is done by:\n multiplication by {02} xor(the original x)\n so that 2+1=3. where xor is the addition of elements in finite fields\n*/\nfunction [7:0] mb3; //multiply by 3\ninput [7:0] x;\n begin \n\nmb3 = mb2(x) ^ x;\n end \nendfunction\n\n\n\n\ngenvar i;\n\ngenerate \nfor(i=0;i< 4;i=i+1) begin : m_col\n\n assign state_out[(i*32 + 24)+:8]= mb2(state_in[(i*32 + 24)+:8]) ^ mb3(state_in[(i*32 + 16)+:8]) ^ state_in[(i*32 + 8)+:8] ^ state_in[i*32+:8];\n assign state_out[(i*32 + 16)+:8]= state_in[(i*32 + 24)+:8] ^ mb2(state_in[(i*32 + 16)+:8]) ^ mb3(state_in[(i*32 + 8)+:8]) ^ state_in[i*32+:8];\n assign state_out[(i*32 + 8)+:8]= state_in[(i*32 + 24)+:8] ^ state_in[(i*32 + 16)+:8] ^ mb2(state_in[(i*32 + 8)+:8]) ^ mb3(state_in[i*32+:8]);\n assign state_out[i*32+:8]= mb3(state_in[(i*32 + 24)+:8]) ^ state_in[(i*32 + 16)+:8] ^ state_in[(i*32 + 8)+:8] ^ mb2(state_in[i*32+:8]);\n\nend\n\nendgenerate\n\nendmodule\n",
	    "name": "mixColumns",
	    "pipeline_stages": "0",
            "valid": " "
        },
        {
	    "instruction": "A module named `async_dualram_16X8`, representing an asynchronous dual-port RAM with a size of 16 bytes (16x8 bits). The module is designed to perform read and write operations independently and asynchronously on the memory array. The key features and functionality of this module are detailed below: Parameters: `ADDR_WIDTH`: The width of the address bus, defined as 4 bits, allowing access to 2^4 (16) memory locations. `DEPTH`: The depth of the RAM, set to 16, indicating the number of memory cells. `DATA_WIDTH`: The width of the data bus, defined as 8 bits, allowing each memory cell to store one byte of data. Ports: `cs`: Chip Select input. The RAM responds to read/write operations only when this signal is active. `rst`: Reset input. When asserted, it initializes the RAM content and the read data output to zero. Write Signals: `wr_enb`: Write Enable input. When active, it allows data to be written to the memory at the address specified by `wr_addr`. `wr_addr`: Write Address input, 4 bits wide, specifies the memory address for the write operation.`wr_data`: Write Data input, 8 bits wide, holds the data to be written into the memory. Read Signals: `rd_enb`: Read Enable input. When active, it allows data to be read from the memory at the address specified by `rd_addr`. `rd_addr`: Read Address input, 4 bits wide, specifies the memory address for the read operation. `rd_data`: Read Data output, 8 bits wide, presents the data read from the memory.",
            "response": "`define ADDR_WIDTH 4\n`define DEPTH 16\n`define DATA_WIDTH 8 \nmodule async_dualram_16X8 (cs,\n            rst,\n            wr_enb,\n            wr_addr,\n            wr_data,\n            rd_enb,\n            rd_addr,\n            rd_data);\n\n//port direction\n  input cs, rst;\n\n //write signals\n  input                   wr_enb;\n  input [`ADDR_WIDTH-1:0] wr_addr;\n  input [`DATA_WIDTH-1:0] wr_data;\n\n //read signals\n  input                        rd_enb;\n  input      [`ADDR_WIDTH-1:0] rd_addr;\n  output reg [`DATA_WIDTH-1:0] rd_data;\n\n\n //internal memory\n reg [`DATA_WIDTH-1:0] ram [0:`DEPTH-1];\n\n reg [`ADDR_WIDTH:0] i;\n\n //implementation\n always@(cs,rst,wr_addr,rd_addr,wr_data,wr_enb,rd_enb)\n  if (rst) \n  begin\n     rd_data <= `DATA_WIDTH'd0;\n\n//memory initialisation\n     for (i=0;i<`DEPTH;i=i+1) \n         ram[i] <= `DATA_WIDTH'd0;\n  end\n  \n  else \n  begin\n    //write logic\n     if (wr_enb && cs)\n        ram[wr_addr] <= wr_data;\n//read logic\n     if (rd_enb && cs)\n        rd_data <= ram[rd_addr];\n  end\n\nendmodule\n",
	    "name": "async_dualram_16X8",
	    "pipeline_stages": "0",
            "valid": " "
        },
        {
	    "instruction": "Defines a module named `inverseMixColumns`, which is a crucial part of the AES (Advanced Encryption Standard) decryption process. The `inverseMixColumns` function is the inverse operation of the `mixColumns` transformation used in AES encryption rounds, designed to operate on the state array and reverse the mixing effect applied during encryption. Inputs and Outputs: Input: `state_in` - A 128-bit input representing the state array that has been transformed during the encryption process. Output: `state_out` - A 128-bit output representing the restored state array after the inverseMixColumns operation. Functionality: The `inverseMixColumns` operation treats each column of the state as a four-term polynomial over the finite field GF(2^8) and multiplies it modulo `x^4 + 1` with a fixed polynomial used for the inverse operation in AES decryption. Key Components: Multiplication Functions: The module defines functions to multiply a byte by `{0e}`, `{0d}`, `{0b}`, and `{09}` in the finite field GF(2^8), which are necessary for the inverse mix columns polynomial in AES decryption. These functions utilize a `multiply` function to perform the multiplication by repeatedly applying multiplication by `{02}` (left shift and conditional XOR with 0x1b for finite field reduction). The multiply function takes an input byte `x` and an integer `n`, representing the number of times to multiply `x` by `{02}`.",
            "response": "module inverseMixColumns(state_in,state_out);\ninput [127:0] state_in;\noutput [127:0] state_out;\n\n/*\nMultiplication by 2 can be implemented at the byte level as a left shift and a subsequent\nconditional bitwise XOR with {1b},where bitwise xor with {1b} is done if x[7]= 1.\nMultiplication by higher powers of x can be implemented by repeated application of multiplication by 2.\n*/\n\n//This function multiply by {02} n-times\nfunction[7:0] multiply(input [7:0]x,input integer n);\ninteger i;\nbegin\n for(i=0;i<n;i=i+1)begin\n if(x[7] == 1) x = ((x << 1) ^ 8'h1b);\n else x = x << 1; \nend\n multiply=x;\nend\n\nendfunction\n\n\n/* \n Multiply by {0e} is done by :\n (multiplying by {02} 3 times which is equivalent to multiplication by {08}) xor\n (multiplying by {02} 2 times which is equivalent to multiplication by {04}) xor\n (multiplying by {02})\n so that 8+4+2= e. where xor is the addition of elements in finite fields\n*/\nfunction [7:0] mb0e; //multiply by {0e}\ninput [7:0] x;\nbegin\nmb0e=multiply(x,3) ^ multiply(x,2)^ multiply(x,1);\nend\nendfunction\n\n/* \n Multiply by {0d} is done by :\n (multiplying by {02} 3 times which is equivalent to multiplication by {08}) xor\n(multiplying by {02} 2 times which is equivalent to multiplication by {04}) xor\n(the original x)\n so that 8+4+1= d. where xor is the addition of elements in finite fields\n*/\nfunction [7:0] mb0d; //multiply by {0d}\ninput [7:0] x;\nbegin\n mb0d=multiply(x,3) ^ multiply(x,2)^ x;\nend\nendfunction\n\n\n/* \n Multiply by {0b} is done by :\n (multiplying by {02} 3 times which is equivalent to multiplication by {08}) xor\n (multiplying by {02}) xor (the original x)\n so that 8+2+1= b. where xor is the addition of elements in finite fields\n*/\n\nfunction [7:0] mb0b; //multiply by {0b}\ninput [7:0] x;\nbegin\n mb0b=multiply(x,3) ^ multiply(x,1)^ x;\nend\nendfunction\n/* \n Multiply by {09} is done by :\n (multiplying by {02} 3 times which is equivalent to multiplication by {08}) xor (the original x)\n so that 8+1= 9. where xor is the addition of elements in finite fields\n*/\n\nfunction [7:0] mb09; //multiply by {09}\ninput [7:0] x;\nbegin\nmb09=multiply(x,3) ^  x;\nend\nendfunction\n\ngenvar i;\n\ngenerate \nfor(i=0;i< 4;i=i+1) begin : m_col\n\n assign state_out[(i*32 + 24)+:8]= mb0e(state_in[(i*32 + 24)+:8]) ^ mb0b(state_in[(i*32 + 16)+:8]) ^ mb0d(state_in[(i*32 + 8)+:8]) ^ mb09(state_in[i*32+:8]);\n assign state_out[(i*32 + 16)+:8]= mb09(state_in[(i*32 + 24)+:8]) ^ mb0e(state_in[(i*32 + 16)+:8]) ^ mb0b(state_in[(i*32 + 8)+:8]) ^ mb0d(state_in[i*32+:8]);\n assign state_out[(i*32 + 8)+:8]= mb0d(state_in[(i*32 + 24)+:8]) ^ mb09(state_in[(i*32 + 16)+:8]) ^ mb0e(state_in[(i*32 + 8)+:8]) ^ mb0b(state_in[i*32+:8]);\n  assign state_out[i*32+:8]= mb0b(state_in[(i*32 + 24)+:8]) ^ mb0d(state_in[(i*32 + 16)+:8]) ^ mb09(state_in[(i*32 + 8)+:8]) ^ mb0e(state_in[i*32+:8]);\n\nend\n\nendgenerate\n\n\nendmodule\n",
	    "name": "inverseMixColumns",
	    "pipeline_stages": "0",
            "valid": " "
        },
        {
            "instruction" : "Implement a `float_to_int_combinational` module, A single 32-bit input (`input_a`), representing the single-precision floating-point number to be converted. A single 32-bit output (`output_z`), which will hold the converted integer value, define a module that accepts a 32-bit input representing a single-precision IEEE 754 floating-point number and outputs a 32-bit integer. Start by decomposing the input into its sign, exponent, and mantissa. Adjust the exponent by subtracting the bias (127) to find the actual exponent value. Normalize the mantissa by adding an implicit '1' for non-zero exponents, resulting in a 24-bit value. Calculate the amount to shift the normalized mantissa to convert it to an integer, considering the actual exponent. Include logic to handle special cases: set the output to 0 for zero or denormalized inputs, and saturate the output at the maximum or minimum integer values for overflow conditions. For normal cases, right-shift the normalized mantissa by the calculated amount and apply the sign to determine the final integer output. This module should use combinational logic to produce the output directly from the input without any clocked operations.",
            "response": "module float_to_int_combinational(\n    input [31:0] input_a,\n    output reg [31:0] output_z\n);\n\n// Unpack the input floating-point number\nwire sign = input_a[31];\nwire [7:0] exponent = input_a[30:23];\nwire [22:0] mantissa = input_a[22:0];\n\n// Calculate the actual exponent value considering the bias (127 for single-precision)\nwire [8:0] actual_exponent = exponent - 8'd127;\n\n// Normalize the mantissa by adding the implicit leading 1 for non-zero exponent\nwire [23:0] normalized_mantissa = |exponent ? {1'b1, mantissa} : {1'b0, mantissa};\n\n// Determine the shift amount to convert the floating-point number to an integer\nwire [8:0] shift_amount = 9'd23 - actual_exponent;\n\n// Special cases handling\nwire is_zero_or_denormalized = (exponent == 0);\nwire is_overflow = (actual_exponent >= 9'd31);\n\n// Perform the shift and apply the sign\nwire [31:0] shifted_mantissa = normalized_mantissa >> shift_amount;\n\n// Generate the output based on special cases and normal conversion\nalways @(*) begin\n    if (is_zero_or_denormalized) begin\n        // For zero and denormalized numbers, the output is 0\n        output_z = 32'd0;\n    end else if (is_overflow) begin\n        // For overflow, saturate the output (max positive or negative value)\n        output_z = sign ? 32'h80000000 : 32'h7FFFFFFF;\n    end else begin\n        // Normal conversion with sign application\n        output_z = sign ? -shifted_mantissa : shifted_mantissa;\n    end\nend\n\nendmodule\n\n",
            "name": "float_to_int_combinational",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction" : "Defines a module named `Addition_Subtraction_Comb` that performs floating-point addition or subtraction on two 32-bit inputs based on the IEEE 754 standard. Inputs and Outputs: It takes two 32-bit inputs `a` and `b`, which are the floating-point numbers to be added or subtracted. The `add_sub_signal` input determines the operation: if it's `1`, the module performs addition; otherwise, it performs subtraction. The output `res` is a 32-bit number representing the result of the operation. The `exception` output signals an exceptional condition, such as overflow or underflow. the `Addition_Subtraction_Comb` module encapsulates the complexities of floating-point addition and subtraction, adhering to the IEEE 754 standard, and includes steps like decomposition, alignment, arithmetic operation, normalization, and result construction, ensuring accurate and standard-compliant results.",
            "response": "module Addition_Subtraction_Comb(\n    input [31:0] a,\n    input [31:0] b,\n    input add_sub_signal, // If 1 then addition, otherwise subtraction\n    output [31:0] res,\n    output exception\n);\n\n// Decompose inputs\nwire [7:0] exp_a = a[30:23];\nwire [7:0] exp_b = b[30:23];\nwire [22:0] mant_a = a[22:0];\nwire [22:0] mant_b = b[22:0];\nwire sign_a = a[31];\nwire sign_b = b[31];\n\n// Determine operation\nwire operation = sign_a ^ sign_b ^ add_sub_signal;\n\n// Extended significands with implied leading '1' or '0' for denormals\nwire [24:0] extended_mant_a = |exp_a ? {1'b1, mant_a} : {1'b0, mant_a};\nwire [24:0] extended_mant_b = |exp_b ? {1'b1, mant_b} : {1'b0, mant_b};\n\n// Align significands based on exponent difference\nwire [7:0] exp_diff = exp_a > exp_b ? exp_a - exp_b : exp_b - exp_a;\nwire [24:0] aligned_mant_a = exp_a >= exp_b ? extended_mant_a : extended_mant_a >> exp_diff;\nwire [24:0] aligned_mant_b = exp_b > exp_a ? extended_mant_b : extended_mant_b >> exp_diff;\nwire [7:0] aligned_exp = exp_a > exp_b ? exp_a : exp_b;\n\n// Perform addition or subtraction\nwire [25:0] sum = operation ? aligned_mant_a + aligned_mant_b : aligned_mant_a - aligned_mant_b;\n\n// Normalize result\nwire [4:0] leading_zeros = count_leading_zeros(sum[24:0]); // Implement this function to count leading zeros\nwire [24:0] normalized_mant = sum << leading_zeros;\nwire [7:0] normalized_exp = aligned_exp - leading_zeros;\n\n// Determine result sign\nwire result_sign = operation ? sign_a : (exp_a > exp_b ? sign_a : sign_b);\n\n// Exception handling (simplified)\nassign exception = &exp_a | &exp_b;\n\n// Construct result\nassign res = {result_sign, normalized_exp[7:0], normalized_mant[22:0]};\n\n// Function to count leading zeros in the significand for normalization\nfunction [4:0] count_leading_zeros(input [24:0] value);\n    begin\n        count_leading_zeros = 0;\n        // Iterate through each bit to count leading zeros\n        for (int i = 24; i >= 0; i--) begin\n            if (value[i] == 1'b1) begin\n                count_leading_zeros = 24 - i;\n                break;\n            end\n        end\n    end\nendfunction\n\nendmodule\n\n",
            "name" :"Addition_Subtraction_Comb",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction" : "Implement the `double_precision_fp_divider_combinational` module, start by defining two 64-bit inputs, `input_a` and `input_b`, for the dividend and divisor, respectively, and a 64-bit output `output_z` for the quotient. Decompose each input into a sign bit, an 11-bit exponent, and a 52-bit mantissa, remembering to account for the implicit leading '1' in normalized mantissas. Implement logic to handle special cases, including NaN, infinity, and zero, based on IEEE 754 rules. For the division operation, simplify by dividing the extended mantissa of `input_a` by the mantissa of `input_b`, and then construct the output using the calculated sign, adjusted exponent, and the most significant bits of the division result. Include caveats about the simplifications made, such as the lack of rounding and precise handling of subnormal numbers.",
            "response": "module double_precision_fp_divider_combinational(\n    input [63:0] input_a,\n    input [63:0] input_b,\n    output reg [63:0] output_z\n);\n\n// Unpack input operands\nwire sign_a = input_a[63];\nwire [10:0] exponent_a = input_a[62:52];\nwire [51:0] mantissa_a = {1'b1, input_a[51:0]}; // Implicit leading 1 for normalized values\n\nwire sign_b = input_b[63];\nwire [10:0] exponent_b = input_b[62:52];\nwire [51:0] mantissa_b = {1'b1, input_b[51:0]}; // Implicit leading 1 for normalized values\n\n// Handle special cases such as NaN, infinity, zero, etc.\n// This is a simplified representation; a full implementation would need more detailed handling\nwire a_is_nan_or_inf = exponent_a == 11'h7FF;\nwire b_is_nan_or_inf = exponent_b == 11'h7FF;\nwire a_is_zero = exponent_a == 0 && mantissa_a == 0;\nwire b_is_zero = exponent_b == 0 && mantissa_b == 0;\n\n// Normalize operands - in a full implementation, this would involve shifting mantissas\n// and adjusting exponents as necessary for subnormal numbers\n\n// Perform division - this is highly simplified and does not represent the actual complexity\n// of floating-point division, especially for double-precision values\nwire [105:0] division_result = {mantissa_a, 54'b0} / mantissa_b; // Extended precision for division\n\n// Determine the result sign and exponent\nwire result_sign = sign_a ^ sign_b;\nwire [10:0] result_exponent = exponent_a - exponent_b + 1023; // Adjust for bias\n\n// Construct the output\nalways @(*) begin\n    if (a_is_nan_or_inf || b_is_nan_or_inf) begin\n        // Handle NaN and infinity cases - this is simplified\n        output_z = {1'b0, 11'h7FF, 52'h0}; // Represents infinity; NaN would require different handling\n    end else if (a_is_zero || b_is_zero) begin\n        // Handle zero cases\n        output_z = {result_sign, 11'h0, 52'h0}; // Represents zero\n    end else begin\n        // Normal operation - simplified and does not include rounding or handling of underflow/overflow\n        output_z = {result_sign, result_exponent, division_result[105:54]}; // Note: rounding not handled\n    end\nend\n\nendmodule\n\n",
            "name": "double_precision_fp_divider_combinational",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction": "The module, named `combinational_fp_divider`, is designed to perform floating-point division on two 32-bit inputs (`input_a` and `input_b`), producing a 32-bit output (`output_z`). The module is structured to handle the division in a combinational manner, meaning it does not rely on clock cycles and produces the output directly from the current inputs. Sign, Exponent, and Mantissa Extraction: Each input is decomposed into its sign bit, 8-bit exponent, and 23-bit mantissa (significand), following the IEEE 754 standard for single-precision floating-point numbers. Simplified Division: The division is greatly simplified, ignoring many complexities of real floating-point division, such as precision, rounding, and range adjustments. The division uses an extended dividend (by appending 24 zeros to `norm_mant_a`) for increased precision, and the quotient is directly calculated from `norm_mant_a` divided by `norm_mant_b`. Mantissa Normalization: For normalized numbers (non-zero exponent), an implicit '1' is prepended to the mantissa, while for denormalized numbers (zero exponent), a '0' is prepended. This step ensures that the division operation has a consistent starting point.  The sign of the result is the XOR of the input signs, and the exponent is calculated by subtracting the exponent of B from that of A and then normalizing to the bias (127 for IEEE 754 single-precision). Special Case Outputs: The module adjusts the output for special cases like NaN, infinity, division by zero, and zero results, setting the output to predefined values for these conditions. Overflow and Underflow: It detects overflow (when the calculated exponent exceeds the representable range) and underflow (when the result is too small to be represented) and sets the output to infinity or zero, respectively. Normal Result: For a normal result, the module constructs the output from the calculated sign, exponent, and the most significant bits of the division result (after normalization and without rounding).",
            "response": "module combinational_fp_divider(\n    input [31:0] input_a,\n    input [31:0] input_b,\n    output reg [31:0] output_z\n);\n\n// Unpack inputs\nwire sign_a = input_a[31];\nwire [7:0] exp_a = input_a[30:23];\nwire [22:0] mant_a = input_a[22:0];\n\nwire sign_b = input_b[31];\nwire [7:0] exp_b = input_b[30:23];\nwire [22:0] mant_b = input_b[22:0];\n\n// Special cases flags\nwire a_is_nan = exp_a == 8'hFF && |mant_a;\nwire b_is_nan = exp_b == 8'hFF && |mant_b;\nwire a_is_inf = exp_a == 8'hFF && ~|mant_a;\nwire b_is_inf = exp_b == 8'hFF && ~|mant_b;\nwire a_is_zero = exp_a == 0 && mant_a == 0;\nwire b_is_zero = exp_b == 0 && mant_b == 0;\n\n// Normalize mantissas (including implicit leading 1 for normalized numbers)\nwire [23:0] norm_mant_a = |exp_a ? {1'b1, mant_a} : {1'b0, mant_a};\nwire [23:0] norm_mant_b = |exp_b ? {1'b1, mant_b} : {1'b0, mant_b};\n\n// Simple division (This part is greatly simplified and not accurate for real FP division)\nwire [47:0] div_result = {norm_mant_a, 24'b0} / norm_mant_b;  // Extended dividend for precision\n\n// Result sign and exponent calculation (simplified, not handling underflow/overflow)\nwire result_sign = sign_a ^ sign_b;\nwire [8:0] result_exp = exp_a - exp_b + 127;  // Note: 9 bits to detect overflow\n\n// Determine output based on special cases and normal division result\nalways @* begin\n    if (a_is_nan || b_is_nan || (a_is_inf && b_is_inf) || (a_is_zero && b_is_zero)) {\n        // NaN cases\n        output_z = {1'b0, 8'hFF, 1'b1, 22'b0};  // signaling NaN\n    } else if (a_is_inf || b_is_zero) {\n        // Infinity or division by zero\n        output_z = {result_sign, 8'hFF, 23'b0};\n    } else if (a_is_zero || b_is_inf) {\n        // Zero or zero result from division by infinity\n        output_z = {result_sign, 8'b0, 23'b0};\n    } else if (result_exp[8]) {\n        // Overflow to infinity\n        output_z = {result_sign, 8'hFF, 23'b0};\n    } else if (result_exp < 0) {\n        // Underflow to zero\n        output_z = {result_sign, 8'b0, 23'b0};\n    } else {\n        // Normalized result, rounding not handled\n        output_z = {result_sign, result_exp[7:0], div_result[46:24]};\n    }\nend\n\nendmodule\n\n",
            "name": "combinational_fp_divider",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction": "Implement a `double_adder_combinational` module for adding two 64-bit IEEE 754 double-precision floating-point numbers, start by defining two 64-bit inputs, `input_a` and `input_b`, and a 64-bit output, `output_z`. Decompose each input into a sign bit, an 11-bit exponent, and a 52-bit mantissa, adding an implicit '1' to the front of each mantissa to represent normalized numbers. Handle special cases such as NaN, infinity, and zero based on IEEE 754 rules. For the arithmetic operation, align the mantissas by shifting based on the exponent difference, then add or subtract them depending on the signs. Normalize the result if necessary by shifting the mantissa and adjusting the exponent. Construct the output from the result sign (assumed to be the same as `input_a`'s sign for simplicity), the adjusted exponent, and the normalized mantissa, omitting the implicit '1'. Note that this implementation simplifies certain aspects, such as rounding and precise handling of edge cases.",
            "response": "module double_adder_combinational(\n    input [63:0] input_a,\n    input [63:0] input_b,\n    output reg [63:0] output_z\n);\n\n// Extract components of the inputs\nwire sign_a = input_a[63];\nwire [10:0] exp_a = input_a[62:52];\nwire [51:0] mant_a = {1'b1, input_a[51:0]};  // Implicit leading '1'\n\nwire sign_b = input_b[63];\nwire [10:0] exp_b = input_b[62:52];\nwire [51:0] mant_b = {1'b1, input_b[51:0]};  // Implicit leading '1'\n\n// Special cases handling\nwire is_a_nan = exp_a == 11'b11111111111 && |mant_a[50:0];\nwire is_b_nan = exp_b == 11'b11111111111 && |mant_b[50:0];\nwire is_a_inf = exp_a == 11'b11111111111 && ~|mant_a[50:0];\nwire is_b_inf = exp_b == 11'b11111111111 && ~|mant_b[50:0];\nwire is_a_zero = exp_a == 0 && mant_a == 0;\nwire is_b_zero = exp_b == 0 && mant_b == 0;\n\n// Compute exponent difference and align mantissas\nwire [10:0] exp_diff = exp_a > exp_b ? exp_a - exp_b : exp_b - exp_a;\nwire [51:0] aligned_mant_a = exp_a > exp_b ? mant_a : mant_a >> exp_diff;\nwire [51:0] aligned_mant_b = exp_b > exp_a ? mant_b : mant_b >> exp_diff;\n\n// Addition/Subtraction of mantissas\nwire [52:0] sum_mantissa = sign_a == sign_b ? aligned_mant_a + aligned_mant_b : (aligned_mant_a > aligned_mant_b ? aligned_mant_a - aligned_mant_b : aligned_mant_b - aligned_mant_a);\nwire result_sign = sign_a;  // Simplified assumption\n\n// Result normalization and rounding (simplified)\nwire [52:0] normalized_mantissa = sum_mantissa[52] ? sum_mantissa >> 1 : sum_mantissa;\nwire [10:0] adjusted_exp = sum_mantissa[52] ? (exp_a > exp_b ? exp_a + 1 : exp_b + 1) : (exp_a > exp_b ? exp_a : exp_b);\n\n// Packing the result\nalways @* begin\n    if (is_a_nan || is_b_nan) begin\n        output_z = {1'b1, 11'b11111111111, 1'b1, 50'd0};  // NaN\n    end else if (is_a_inf || is_b_inf) begin\n        output_z = {result_sign, 11'b11111111111, 52'd0};  // Infinity\n    end else if (is_a_zero && is_b_zero) begin\n        output_z = {sign_a & sign_b, 11'd0, 52'd0};  // Zero\n    end else begin\n        output_z = {result_sign, adjusted_exp, normalized_mantissa[51:0]};  // Normal case\n    end\nend\n\nendmodule\n\n",
            "name": "double_adder_combinational",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction" : "Implement the `high_radix_multiplication` module, create a module with two 16-bit inputs, `x` and `y`, for the operands, and a 32-bit output `out_o` for the product. Begin by computing the two's complement of `x` (`inv_x`) for generating negative partial products. Use a generate block with a loop to iterate over 2-bit segments of `y`, generating partial products according to the high-radix Booth's algorithm. Store these partial products in an array products. For each segment of `y`, generate a partial product based on the value of the 2-bit segment: `0` for `00` or `11`, `x` for `01`, and `-x` (`inv_x`) for `10`, shifting each partial product left by twice the iteration index to align it properly. `Sum` the partial products in pairs and store the intermediate sums in an array `sum`. Continue summing the intermediate sums until you obtain the final product, which should be assigned to `out_o`. Ensure that each step accounts for the sign and position of the partial products to accurately represent the multiplication result.",
            "response": "module high_radix_multiplication(x, y, out_o);\n    input [15:0] x, y;\n    output [31:0] out_o;\n\n    wire [15:0] inv_x = (~x) + 1'b1;\n    wire [31:0] products[0:7]; // Array to hold partial products\n    wire [31:0] sum[0:6]; // Intermediate sums, used for the final reduction\n\n    // Generate partial products based on the high-radix (radix-4) Booth's algorithm\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : gen_partial_products\n            wire [1:0] y_bits = y[2*i+1:2*i]; // Take 2 bits of y\n            case (y_bits)\n                2'b00, 2'b11: products[i] = 32'b0; // 0 or -0\n                2'b01: products[i] = { {16{x[15]}}, x }; // +x\n                2'b10: products[i] = { {16{inv_x[15]}}, inv_x }; // -x\n            endcase\n\n            // Shift the partial products according to their position\n            if (i > 0) begin\n                products[i] = products[i] << (2*i);\n            end\n        end\n    endgenerate\n\n    // Sum up all the partial products\n    assign sum[0] = products[0] + products[1];\n    assign sum[1] = products[2] + products[3];\n    assign sum[2] = products[4] + products[5];\n    assign sum[3] = products[6] + products[7];\n    assign sum[4] = sum[0] + sum[1];\n    assign sum[5] = sum[2] + sum[3];\n    assign out_o = sum[4] + sum[5]; // Final output is the sum of all intermediate sums\n\nendmodule\n\n",
            "name": "high_radix_multiplication",
            "pipeline_stages": "0",
            "valid": " "
        },
        {
        "instruction" : "Implement the `fmultiplier_comb` module, create a module with two 32-bit inputs, `a` and `b`, representing single-precision IEEE 754 floating-point numbers, and a 32-bit output `z` for the multiplication result. Begin by extracting the sign, exponent, and mantissa from each input, remembering to include an implicit '1' for the mantissa of normalized numbers. Address special cases such as zero, infinity, and NaN by checking the exponent and mantissa values. Calculate the result exponent by adding the input exponents and adjusting for the bias. Multiply the mantissas, normalize the product, and apply simplified rounding. Use combinational logic to set `z` based on these calculations, handling NaN, infinity, and zero appropriately, and combining the sign, exponent, and mantissa for other cases. Ensure the module operates without clock signals, producing the output directly from the inputs.",
            "response": "module fmultiplier_comb(a, b, z);\n\n    input [31:0] a, b;\n    output reg [31:0] z;\n\n    // Decompose inputs\n    wire [7:0] a_exp, b_exp;\n    wire [23:0] a_mant, b_mant;\n    wire a_sign, b_sign;\n\n    assign a_sign = a[31];\n    assign b_sign = b[31];\n    assign a_exp = a[30:23];\n    assign b_exp = b[30:23];\n    assign a_mant = {1'b1, a[22:0]}; // Implicit leading 1 for normalized values\n    assign b_mant = {1'b1, b[22:0]};\n\n    // Special cases\n    wire a_is_zero, b_is_zero, a_is_inf, b_is_inf, a_is_nan, b_is_nan;\n    assign a_is_zero = (a_exp == 0) && (a[22:0] == 0);\n    assign b_is_zero = (b_exp == 0) && (b[22:0] == 0);\n    assign a_is_inf = (a_exp == 255) && (a[22:0] == 0);\n    assign b_is_inf = (b_exp == 255) && (b[22:0] == 0);\n    assign a_is_nan = (a_exp == 255) && (a[22:0] != 0);\n    assign b_is_nan = (b_exp == 255) && (b[22:0] != 0);\n\n    // Compute exponent\n    wire [8:0] exp_sum;\n    wire [7:0] z_exp;\n    assign exp_sum = a_exp + b_exp - 127; // Subtract bias from one exponent\n    assign z_exp = exp_sum[7:0]; // Might need adjustment for overflow/underflow\n\n    // Multiply mantissas\n    wire [47:0] mant_product;\n    assign mant_product = a_mant * b_mant;\n\n    // Normalize product\n    wire [23:0] normalized_mant;\n    wire need_shift;\n    assign need_shift = mant_product[47];\n    assign normalized_mant = need_shift ? mant_product[47:24] : mant_product[46:23];\n\n    // Rounding (simplified, rounding to nearest even)\n    wire [23:0] rounded_mant;\n    wire round_bit;\n    assign round_bit = need_shift ? mant_product[23] : mant_product[22];\n    assign rounded_mant = round_bit ? normalized_mant + 1 : normalized_mant;\n\n    always @(*) begin\n        if (a_is_nan || b_is_nan) begin\n            z = {1'b0, 8'hFF, 1'b1, 22'b0}; // NaN\n        end else if (a_is_inf || b_is_inf) begin\n            if (a_is_zero || b_is_zero) begin\n                z = {1'b0, 8'hFF, 1'b1, 22'b0}; // NaN (Inf * 0)\n            end else begin\n                z = {a_sign ^ b_sign, 8'hFF, 23'b0}; // Infinity\n            end\n        end else if (a_is_zero || b_is_zero) begin\n            z = {a_sign ^ b_sign, 31'b0}; // Zero\n        end else begin\n            // Set the sign bit, exponent, and mantissa\n            z[31] = a_sign ^ b_sign;\n            z[30:23] = z_exp;\n            z[22:0] = rounded_mant[22:0];\n        end\n    end\n\nendmodule\n\n",
            "name": "fmultiplier_comb",
            "pipeline_stages": "0",
            "valid": " "
        }
    ]
}
